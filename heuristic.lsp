(defun heuristic ( state player not_player )
	( let ( value )
		;Checks 4 corners and gives those moves high priority
		( when ( equal ( nth 1 ( nth 1 state ) ) '- )
			( when ( equal ( nth 2 ( nth 1 state ) ) player )
				( seft value ( + value 50 ) )
			)
			( when ( equal ( nth 2 ( nth 2 state ) ) player )
				( seft value ( + value 50 ) )
			)
			( when ( equal ( nth 1 ( nth 2 state ) ) player )
				( seft value ( + value 50 ) )
			)
		)

		( when ( equal ( nth 1 ( nth 8 state ) ) '- )
			( when ( equal ( nth 2 ( nth 8 state ) ) player )
				( seft value ( + value 50 ) )
			)
			( when ( equal ( nth 2 ( nth 7 state ) ) player )
				( seft value ( + value 50 ) )
			)
			( when ( equal ( nth 1 ( nth 7 state ) ) player )
				( seft value ( + value 50 ) )
			)
		)

		( when ( equal ( nth 8 ( nth 1 state ) ) '- )
			( when ( equal ( nth 7 ( nth 1 state ) ) player )
				( seft value ( + value 50 ) )
			)
			( when ( equal ( nth 7 ( nth 2 state ) ) player )
				( seft value ( + value 50 ) )
			)
			( when ( equal ( nth 8 ( nth 2 state ) ) player )
				( seft value ( + value 50 ) )
			)
		)

		( when ( equal ( nth 8 ( nth 8 state ) ) '- )
			( when ( equal ( nth 7 ( nth 8 state ) ) player )
				( seft value ( + value 50 ) )
			)
			( when ( equal ( nth 7 ( nth 7 state ) ) player )
				( seft value ( + value 50 ) )
			)
			( when ( equal ( nth 8 ( nth 7 state ) ) player )
				( seft value ( + value 50 ) )
			)
		)
		;checks the mobility for each player (number of posible moves) and compares them
		( setf value ( - value ( - ( length generate_successors player ) ( length generate_successors not_player ) ) ) )

	)
)
